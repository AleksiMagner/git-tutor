<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<title>Руководство по работе с Git</title>
	<link rel="stylesheet" href="style.css">
</head>
<body>
	<main>
		<h1>Руководство по работе с Git</h1>
		<span id="items"></span>
		<section>
			<span id="item1"></span>
			<a href="#item1" id="open-item1">Часто используемые команды</a>
			<a href="#items" id="close-item1">Часто используемые команды</a>
			<div class="content">
<pre><code>git add . // добавление всех изменений в индекс
git com 'Комментарий' // добавление всех изменений в индекс (если файл до этого был уже в индексе) и сохранение (коммит)
git coma 'Сообщение коммита' // изменение последнего коммита
git revert [hash] // отмена коммита для удалённого репозитория
git del [hash] // удаление локальных коммитов из истории после указанного
git st // текущий статус
git hist // краткая история изменений
git hist-f // полная история изменений
git go -b [namebranch] // создание новой ветки и переключение на неё
git go [name] // переключение на новую ветку, возврат к исходной версии файла
git branch -d [namebranch] // удаление ветки
git merge [namebranch] // объединение ветки с текущей
git cp [Commit1] [Commit2] [...] // перенос отдельных коммитов на текущую ветку
git push // отправка изменений в оригинальный репозиторий
git fetch --all // загрузка объектов и ссылок из другого репозитория
git pull // извлечение изменений и объединение с другим репозиторием или локальной веткой</code></pre>

				<p>Чтобы постоянно не вводить одни и те же команды, в файле настроек git настраиваются сокращения (alias).</p>
				<p>Для этого нужно открыть файл ~/.gitconfig и добавить в него сокращения команд. Например:</p>
<pre><code>[alias]
  com = commit -a -m
  coma = commit --amend -m
  del = reset --hard
  hist = log --oneline --decorate=short --graph
  hist-f = log --abbrev-commit --decorate=short --date=local --graph
  st = status
  go = checkout
  cp = cherry-pick
  type = cat-file -t
  dump = cat-file -p
</code></pre>
				<p>Теперь набор команды, например, <code>git com 'Сообщение коммита'</code> будет аналогичен <code>git commit -a -m 'Сообщение коммита'</code>.</p>
			</div>
		</section>

		<section>
			<span id="item2"></span>
			<a href="#item2" id="open-item2">Изменение файлов и отмена изменений</a>
			<a href="#items" id="close-item2">Изменение файлов и отмена изменений</a>
			<div class="content">
				<h3>До внесения изменений в индекс</h3>
				<p>После внесения изменений в файлы репозитория можно сделать следующее:</p>
				<ul>
					<li>Добавить изменения в индекс для последующего сохранения в репозитории:
<pre><code>git add .</code>
или
<code>git add [name]</code></pre>
					</li>
					<li>Отменить изменения:
<pre><code>git checkout -- .</code>
или
<code>git checkout -- [name]</code></pre>
					</li>
				</ul>

				<p>Самый краткий и удобный путь для добавления всех изменений в файлы текущего каталога и его подкаталоги &ndash; это использовать в качестве имени файла текущий каталог («.»).</p>
				<p>Но поскольку он добавляет всё, не лишним будет проверить состояние перед запуском <code>commit</code>, просто чтобы убедиться, что вы не добавили какой-то файл, который добавлять было не нужно.</p>

				<h3>После внесения изменений в индекс</h3>
				<ul>
					<li>Сделать сохранение проиндексированных изменений в репозитории:
						<pre><code>git commit -m 'Сообщение коммита'</code></pre>
					</li>
					<li>Убрать изменённые файлы из индекса:
<pre><code>git reset HEAD [name]</code>
или
<code>git reset HEAD .</code></pre>
					</li>
				</ul>

				<p>Отдельный шаг индексации в git позволяет продолжать вносить изменения в рабочий каталог, а затем, в момент, когда вы захотите взаимодействовать с версионным контролем, git позволит записать изменения в малых коммитах, которые фиксируют то, что вы сделали.</p>

				<p>При использовании команды <code>git commit</code> без параметров появится интерактивное окно редактора, где нужно будет ввести сообщение коммита.</p>
				<p>После ввода сообщения нужно нажать <code>Ctrl + X</code> &rarr; <code>Y</code> &rarr; <code>Enter</code> для сохранения и выхода из редактора</p>
			</div>
		</section>

		<section>
			<span id="item3"></span>
			<a href="#item3" id="open-item3">Изменение и удаление тегов и коммитов</a>
			<a href="#items" id="close-item3">Изменение и удаление тегов и коммитов</a>
			<div class="content">
				<h3>Внесение изменений в коммиты</h3>
				<p>Если вдруг после сделанного коммита появилась необходимость внести несколько мелких изменений и делать ради этого новый коммит не нужно, можно перезаписать последний коммит.</p>
				<p>Добавляем в индекс новые изменения после последнего сделанного коммита:</p>
				<pre><code>git add [имя файла]</code></pre>
				<p>Заменяем последний коммит на новый:</p>
				<pre><code>git commit --amend -m 'Сообщение коммита'</code></pre>

				<p>Этого же эффекта можно достичь путём сброса последнего коммита в ветке, и повторного коммита новых изменений.</p>

				<h3>Перемещение изменений</h3>
				<p>Речь идёт о перемещении изменений — возможности, позволяющей разработчику сказать: «Хочу, чтобы эти изменения были вот тут, а вот эти — вон там» и получить точные, правильные результаты, не теряя при этом гибкости разработки.</p>
				<p>В этом поможет команда <code>cherry-pick</code>:</p>
				<pre><code>git cherry-pick [Commit1] [Commit2] [...]</code></pre>
				<p>Это очень простой и прямолинейный способ сказать, что ты хочешь копировать несколько коммитов на место, где сейчас находишься (<code>HEAD</code>).</p>

				<h3>Интерактивный rebase</h3>
				<p><code>cherry-pick</code> прекрасен, когда точно известно, какие коммиты нужны (и известны их точные хэши).</p>
				<p>Но как быть в случае, когда точно не известно какие коммиты нужны? К счастью, Git позаботился о таких ситуациях! Можно использовать интерактивный <code>rebase</code> для этого &ndash; лучший способ отобрать набор коммитов для <code>rebase</code>.</p>
				<p>Всё, что нужно для интерактивного <code>rebase</code> &ndash; это опция <code>-i</code>.</p>
				<p>Если добавить эту опцию, Git откроет интерфейс просмотра того, какие коммиты готовы к копированию на цель <code>rebase</code> (<code>target</code>). Также показываются хэши коммитов и комментарии к ним, так что можно легко понять что к чему.</p>
				<p>После открытия окна интерактивного <code>rebase</code> есть три варианта для каждого коммита:</p>
				<ul>
					<li>Можно сменить положение коммита по порядку, переставив строчку с ним в редакторе.</li>
					<li>Можно «выкинуть» коммит из ребейза. Для этого есть pick - переключение его означает, что нужно выкинуть коммит.</li>
					<li>Можно объединить изменения двух коммитов.</li>
				</ul>

				<p>Взять последние 4 коммита и выполнить в интерактивном режиме:</p>
				<pre><code>git rebase -i HEAD~4</code></pre>

				<p>Команды интерактивного режима:</p>
				<ul>
					<li><code>p, pick</code> &ndash; использовать коммит</li>
					<li><code>r, reword</code> &ndash; использовать коммит, но изменить сообщение коммита</li>
					<li><code>e, edit</code> &ndash; использовать коммит, но остановиться для внесения правок</li>
					<li><code>s, squash</code> &ndash; использовать коммит, но объединить его с предыдущим коммитом</li>
					<li><code>f, fixup</code> &ndash; как <code>squash</code>, но отбросить сообщение этого коммита</li>
					<li><code>x, exec</code> &ndash; выполнить команду (остаток строки) с помощью командной оболочки</li>
					<li><code>d, drop</code> &ndash; удалить коммит</li>
				</ul>

				<h3>Удаление коммитов из локальной ветки</h3>
				<p>В этом поможет команда <code>reset</code>. При получении ссылки на коммит (т.е. хэш, ветка или имя тега), команда <code>reset</code>…</p>
				<ul>
					<li>Перепишет текущую ветку, чтобы она указывала на нужный коммит;</li>
					<li>Опционально сбросит буферную зону для соответствия с указанным коммитом;</li>
					<li>Опционально сбросит рабочий каталог для соответствия с указанным коммитом.</li>
				</ul>

				<p>Но прежде чем удалить коммиты, отметим последний коммит тегом, чтобы потом можно было его найти:</p>
				<pre><code>git tag oops</code></pre>

				<p>Предположим, что нужно удалить все коммиты, идущие после коммита с тегом <code>v1</code>.</p>
				<pre><code>git reset --hard v1</code></pre>

				<p>Если тега нет, можно использовать хэш-значение.</p>
				<p>Параметр <code>--hard</code> указывает, что рабочий каталог должен быть обновлён в соответствии с новым <code>HEAD</code> ветки.</p>

				<p>Сам ошибочный тег <code>oops</code> остался в репозитории. Увидеть в истории можно командой <code>git log --all</code>.</p>
				<p>Коммиты, на которые нет ссылок, остаются в репозитории до тех пор, пока не будет запущен сборщик мусора.</p>

				<h3>Удаление тега oops (уборка)</h3>
				<p>Тег <code>oops</code> свою функцию выполнил. Чтобы удалить его и коммиты, на которые он ссылался, воспользуемся сборщиком мусора:</p>
				<pre><code>git tag -d oops</code></pre>

				<h3>Отмена коммитов</h3>
				<p><code>Reset</code> отлично работает на локальных ветках, в локальных репозиториях. Но этот метод переписывания истории не сработает на удалённых ветках, которые используют другие пользователи.</p>
				<p>Чтобы отменить изменения и поделиться отменёнными изменениями с остальными, надо использовать <code>revert</code>. Эта команда сделает коммит, который удаляет изменения, сохранённые нежелательным коммитом:</p>
				<pre><code>git revert HEAD</code></pre>

				<p>При использовании <code>HEAD</code> отменяется самый последний произведённый коммит.</p>
				<p>Для отмены произвольного коммита, вместо <code>HEAD</code> нужно подставить хэш коммита из истории.</p>
			</div>
		</section>

		<section>
			<span id="item4"></span>
			<a href="#item4" id="open-item4">Текущее состояние и история</a>
			<a href="#items" id="close-item4">Текущее состояние и история</a>
			<div class="content">
				<p>Проверка текущего состояния:</p>
				<pre><code>git status</code></pre>

				<p>Получение списка произведённых изменений (история):</p>
				<pre><code>git log</code></pre>
				<p>Ключи для команды:</p>
				<ul>
					<li><code>--format=[param]</code> &ndash; формат отображения истории
						<ul>
							<li><code>oneline</code> &ndash; однострочное отображение. Хэш коммита, сообщение</li>
							<li><code>short</code> &ndash; хэш коммита, автор, сообщение</li>
							<li><code>medium</code> &ndash; хэш коммита, автор, дата, сообщение. Стандартное отображение</li>
						</ul>
					</li>
					<li><code>--abbrev-commit</code> &ndash; сокращает хэш коммита для лучшей читаемости</li>
					<li><code>--oneline</code> &ndash; однострочное отображение истории с сокращением хэша коммитов. Аналог <code>--format=oneline --abbrev-commit</code></li>
					<li><code>-2</code> &ndash; последние два коммита</li>
					<li><code>--after='5 minutes ago'</code> &ndash; показать коммиты, созданные позже, чем указанная дата (5 минут назад)</li>
					<li><code>--before='5 minutes ago'</code> &ndash; показать коммиты, созданные раньше, чем указанная дата (5 минут назад)</li>
					<li><code>--author=AleksiMagner</code> &ndash; показать только коммиты указанного автора (AleksiMagner)</li>
					<li><code>--graph</code> &ndash; отображает дерево коммитов в виде ASCII-графика</li>
					<li><code>--date=local</code> &ndash; отображать дату в локальном формате</li>
					<li><code>--decorate=short</code> &ndash; дополнения коммита («головы» веток или теги)</li>
					<li><code>--all</code> &ndash; отображение всех коммитов со всех веток сразу</li>
				</ul>
				<p>Руководство по команде:</p>
				<pre><code>man git log</code></pre>
				<p>Оптимальным сочетанием для короткого отображения истории будет команда:</p>
				<pre><code>git log --oneline --decorate=short --graph</code></pre>

				<p>Оптимальным сочетанием для подробного отображения истории будет команда:</p>
				<pre><code>git log --abbrev-commit --decorate=short --date=local --graph</code></pre>

				<p>Показ коммитов со всех веток:</p>
				<pre><code>git log --graph --all</code></pre>
				<p>При использовании ключа <code>--graph</code> можно графически увидеть есть ли расхождения в ветках и какой коммит является предшественником расхождения.</p>
			</div>
		</section>

		<section>
			<span id="item6"></span>
			<a href="#item6" id="open-item6">Переход по коммитам и работа с тегами</a>
			<a href="#items" id="close-item6">Переход по коммитам и работа с тегами</a>
			<div class="content">
				<p>Получить доступ к сохранённой версии файла можно трёмя способами:</p>
				<ul>
					<li>Переход по хэшу коммита;</li>
					<li>Переход по тегу;</li>
					<li>Переход по относительным ссылкам.</li>
				</ul>

				<h3>Переход по хэшу</h3>
				<p>Для перехода по хэшу коммита достаточно знать первые 7 символов хэша. Узнать их можно просмотрев всю историю:</p>
				<pre><code>git log --abbrev-commit --all</code></pre>
				<p>Узнав хэш необходимого сохранения переходим к нему:</p>
				<pre><code>git checkout [hash]</code></pre>

				<h3>Переход по тегу</h3>
				<p>Если у коммита установлен тег, можно перейти напосредственно по тегу:</p>
				<pre><code>git checkout [имя тега]</code></pre>
				<p>Создать тег можно командой:</p>
				<pre><code>git tag [имя тега]</code></pre>
				<p>Просмотреть список установленных тегов командой:</p>
				<pre><code>git tag</code></pre>

				<h3>Переход по относительной ссылке</h3>
				<p>Для обозначения относительной ссылки используются символы «^» и «~». Символ <code>^</code> перемещает по дереву на 1 коммит, а символ <code>~</code> на указанное число коммитов.</p>
				<p>Например, если необходимо перейти на 4 коммита назад в ветке master, то можно выполнить:</p>
				<pre><code>git checkout master^^^^</code></pre>
				<p>или</p>
				<pre><code>git checkout master~4</code></pre>

				<h3>Принудительное перемещение ветки</h3>
				<p>Чтобы принудительно переместить ветку на другой коммит, используется команда forcing`а:</p>
				<pre><code>git branch -f [имя ветки] [указатель]</code></pre>

				<h3>Примеры</h3>
				<p>Предположим, в проекте есть две ветки &ndash; <code>master</code> и <code>develop</code>.</p>
				<p>Общее количество коммитов &ndash; 15. <code>master</code> находится на коммите C12, <code>develop</code> находится на коммите C7, а текущее положение (<code>HEAD</code>) на коммите C3.</p>
				<p>Есть задача: не меняя текущего положения (не перемещая <code>HEAD</code>), ветку <code>master</code> переместить на последний коммит, а ветку <code>develop</code> на второй коммит. Затем изменить текущее положение на коммит C10.</p>
				<p>Наиболее простым и коротким решением будет:</p>
<pre><code>git branch -f master C15 // принудительно переместили master на последний коммит
git branch -f develop HEAD^ // сместили ветку develop относительно HEAD на 1 коммит назад
git checkout C10 // перестили HEAD на C10</code></pre>
			</div>
		</section>

		<section>
			<span id="item8"></span>
			<a href="#item8" id="open-item8">Git внутри: поиск файлов через каталог .git</a>
			<a href="#items" id="close-item8">Git внутри: поиск файлов через каталог .git</a>
			<div class="content">
				<p>Поиск последнего коммита:</p>
				<pre><code>git log -1</code></pre>
				<p>Вывод последнего коммита:</p>
<pre><code>git cat-file -t [hash]
git cat-file -p [hash]</code></pre>

				<p>Это вывод объекта коммита, который находится во главе ветки.</p>

				<p>Поиск дерева:</p>
				<pre><code>git cat-file -p [treehash]</code></pre>
				<p>Вывод каталога:</p>
				<pre><code>git cat-file -p [cathash]</code></pre>
				<p>Вывод файла:</p>
				<pre><code>git cat-file -p [filehash]</code></pre>
			</div>
		</section>

		<section>
			<span id="item9"></span>
			<a href="#item9" id="open-item9">Работа с ветками</a>
			<a href="#items" id="close-item9">Работа с ветками</a>
			<div class="content">
				<h3>Список веток</h3>
				<p>Просмотр локальных веток:</p>
				<pre><code>git branch</code></pre>

				<p>Просмотр всех удалённых, и локальных веток:</p>
				<pre><code>git branch -a</code></pre>

				<h3>Создание и переключение между ветками</h3>
				<p>Создание и переключение на новую ветку:</p>
				<pre><code>git checkout -b [имя ветки]</code></pre>
				<p>или</p>
<pre><code>git branch [имя ветки] // создание новой ветки
git checkout [имя ветки] // переключение на ветку</code></pre>

				<h3>Добавление локальной ветки, которая отслеживает удалённую ветку.</h3>
				<p>Предположим, в оригинальном репозитории создана ветка <code>release</code>. Но при клонировании перенесётся только ветка <code>master</code>.</p>
				<p>Чтобы сделать такую же ветку в клоне с отслеживанием оригинальной ветки:</p>
				<pre><code>git branch --track release origin/release</code></pre>

				<h3>Слияние веток</h3>
				<p>Слияние переносит изменения из двух веток в одну. Например, нужно слить ветку <code>master</code> с веткой <code>develop</code>:</p>
<pre><code>git checkout develop // переход на ветку develop
git merge master // слияние веток
git log --graph --all // просмотр изменений</code></pre>

				<p>Путём периодического слияния веток можно переносить любые изменения и поддерживать совместимость изменений ветки с изменениями в основной ветке.</p>
				<p>Однако, это делает графики коммитов действительно уродливыми.</p>

				<h3>Перебазирование как альтернатива слиянию</h3>
				<p>Использование команды <code>rebase</code> вместо команды <code>merge</code>:</p>
<pre><code>git checkout develop
git rebase master
git log --graph --all</code></pre>

				<p>Конечный результат перебазирования очень похож на результат слияния. Ветка <code>develop</code> в настоящее время содержит все свои изменения, а также все изменения ветки <code>master</code>. Однако, дерево коммитов значительно отличается.</p>
				<p>Дерево коммитов ветки <code>develop</code> было переписано таким образом, что ветка <code>master</code> является частью истории коммитов. Это делает цепь коммитов линейной и гораздо более читабельной.</p>

				<h3>Когда использовать перебазирование, а когда слияние?</h3>
				<p>Не используйте перебазирование:</p>
				<ul>
					<li>Если ветка является публичной и расшаренной. Переписывание общих веток будет мешать работе других членов команды.</li>
					<li>Когда важна точная история коммитов ветки (так как команда <code>rebase</code> переписывает историю коммитов).</li>
				</ul>

				<p>Учитывая приведённые выше рекомендации, я предпочитаю использовать <code>rebase</code> для кратковременных, локальных веток, а слияние для веток в публичном репозитории.</p>
			</div>
		</section>

		<section>
			<span id="item10"></span>
			<a href="#item10" id="open-item10">Клонирование репозиториев</a>
			<a href="#items" id="close-item10">Клонирование репозиториев</a>
			<div class="content">
				<p>Перед клонированием нужно находиться в рабочем каталоге, где нужно создать клон.</p>
				<p>Для проверки, можно узнать текущее месторасположение:</p>
<pre><code>pwd // показывает полный путь к текущему каталогу
ls // показывает содержимое каталога</code></pre>

				<p>Источником клона может служить как удалённый репозиторий, так и локальный каталог. Если не использовать параметр имени клона, будет создано имя источника.</p>
				<p>Создание клона:</p>
				<pre><code>git clone [источник] [имя копии]</code></pre>
				<p>Например, сделать клон репозитория <a href="https://github.com/AleksiMagner/git-tutor" target="_blank"><code>https://github.com/AleksiMagner/git-tutor</code></a>:</p>
				<pre><code>git clone git@github.com:AleksiMagner/git-tutor.git</code></pre>
				<p>Сделать клон локальной папки <code>work</code>:</p>
				<pre><code>git clone work work_clone</code></pre>
				<p>После создания клона необходимо войти в каталог:</p>
<pre><code>cd git-tutor
или
cd work</code></pre>

				<p>Находясь в клоне:</p>
<pre><code>git remote // удалённое имя оригинального репозитория. По умолчанию origin
git remote show origin // более подробная информация об удалённом репозитории
git branch // список локальных веток клона
git branch -a // список и удалённых, и локальных веток</code></pre>

				<p>Git выводит все коммиты в оригинальный репозиторий, но ветки в удалённом репозитории не рассматриваются как локальные. Если мы хотим собственную ветку, мы должны сами её создать.</p>
			</div>
		</section>

		<section>
			<span id="item11"></span>
			<a href="#item11" id="open-item11">Чистый репозиторий</a>
			<a href="#items" id="close-item11">Чистый репозиторий</a>
			<div class="content">
				<p>Чистые репозитории (без рабочих каталогов) обычно используются для расшаривания.</p>
				<p>Обычный git-репозиторий подразумевает, что вы будете использовать его как рабочую директорию, поэтому вместе с файлами проекта в актуальной версии, git хранит все служебные, «чисто-репозиториевские» файлы в поддиректории <code>.git</code>.</p>
				<p>В удалённых репозиториях нет смысла хранить рабочие файлы на диске (как это делается в рабочих копиях), а всё что им действительно нужно — это дельты изменений и другие бинарные данные репозитория.</p>
				<p>Вот это и есть «чистый репозиторий».</p>
				<p>Перейти в каталог, где находится репозиторий, с которого необходимо сделать чистый репозиторий и выполнить:</p>
				<pre><code>git clone --bare [имя репо] [имя репо].git // создаст чистый репозиторий на основе [имя репо]</code></pre>

				<p>Как правило, репозитории, оканчивающиеся на <code>.git</code> являются чистыми репозиториями.</p>
				<p>В репозитории <code>[имя репо].git</code> нет рабочего каталога. По сути, это есть не что иное, как каталог <code>.git</code> нечистого репозитория.</p>

				<h3>Добавление чистого репозитория к оригинальному в качестве удалённого репозитория</h3>
				<p>Перейти в каталог оригинального репозитория и выполнить:</p>
				<pre><code>git remote add shared ../repo.git</code></pre>
				<p>где <code>shared</code> &ndash; имя удалённого репо, <code>../repo.git</code> &ndash; путь к нему</p>

				<h3>Отправка изменений на общий репозиторий</h3>
				<p>Общим называется репозиторий, получающий отправленные нами изменения.</p>
				<pre><code>git push shared master // shared это имя удалённого репо, master это ветка на которую отправить</code></pre>

				<h3>Извлечение изменений из общего репозитория</h3>
				<pre><code>git branch --track shared master // добавил ветку shared, которая отслеживает master на общем репо</code></pre>
				<pre><code>git pull shared master // получение и слитие данных из репо shared, ветка master</code></pre>
			</div>
		</section>

		<section>
			<span id="item12"></span>
			<a href="#item12" id="open-item12">Настройка git сервера для совместного использования репозиториев</a>
			<a href="#items" id="close-item12">Настройка git сервера для совместного использования репозиториев</a>
			<div class="content">
				<p>Перейти в рабочую директорию.</p>
				<p>Запуск git сервера:</p>
				<pre><code>git daemon --verbose --export-all --base-path=.</code></pre>

				<p>Открыть отдельное окно терминала и перейти в рабочую дерикторию.</p>
<pre><code>git clone git://localhost/repo.git network_repo
cd network_repo
ls</code></pre>

				<p>Должна появиться копия проекта repo, которая хранится в чистом репозитори repo.git</p>

				<h3>Отправка в Git Daemon</h3>
				<p>Если вы хотите совершить отправку в репозиторий <code>Git Daemon</code>, добавьте метку <code>--enable=receive-pack</code> к команде <code>git daemon</code>. Будьте осторожны, этот сервер не производит аутентификацию, поэтому любой может отправлять изменения в ваш репозиторий.</p>
			</div>
		</section>

		<section>
			<span id="item13"></span>
			<a href="#item13" id="open-item13">Ресурсы в помощь</a>
			<a href="#items" id="close-item13">Ресурсы в помощь</a>
			<div class="content">
				<p><a href="https://githowto.com/ru" target="_blank">Git How To</a> &ndash; это интерактивный тур, который познакомит вас с основами Git</p>
				<p><a href="https://git-scm.com/book/ru/v2" target="_blank">Книга Pro Git на русском</a></p>
				<p><a href="https://learngitbranching.js.org/" target="_blank">LearnGitBranching</a> &ndash; интерактивное онлайн-приложение, помогает новичкам постичь мощные возможности ветвления и работы с git.</p>
				<p><a href="https://habr.com/ru/post/106912/" target="_blank">Удачная модель ветвления для Git</a> &ndash; используется при разработке проектов.</p>
				<p><a href="http://gitignore.io/" target="_blank">gitignore</a> &ndash; облегчает создание файлов <code>.gitignore</code> для проектов.</p>
			</div>
		</section>
	</main>

</body>
</html>