<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<title>Руководство по работе с Git</title>
	<link rel="stylesheet" href="style.css">
</head>
<body>
	<main>
		<h1>Руководство по работе с Git</h1>

		<ul id="tabs-v">
			<li data-title="Часто используемые команды и сокращения" class="content">
				<ul>
					<li><code>git st</code> // текущий статус</li>
					<li><code>git hist</code> // краткая история изменений</li>
					<li><code>git histf</code> // полная история изменений</li>
					<li>&nbsp;</li>
					<li><code>git add .</code> // добавление новых файлов в индекс</li>
					<li><code>git com 'Сообщение'</code> // добавление всех изменений в индекс и сохранение</li>
					<li><code>git coma 'Сообщение'</code> // изменение последнего коммита</li>
					<li><code>git del [hash]</code> // удаление локальных коммитов из истории после указанного</li>
					<li><code>git revert [hash]</code> // отмена коммита для удалённого репозитория</li>
					<li>&nbsp;</li>
					<li><code>git go -b [namebranch]</code> // создание новой ветки и переключение на неё</li>
					<li><code>git brd [namebranch]</code> // удаление ветки</li>
					<li><code>git go [name]</code> // переключение на новую ветку, возврат к исходной версии файла</li>
					<li><code>git move [namebranch] [hash]</code> // принудительное перемещение ветки на другой коммит</li>
					<li>&nbsp;</li>
					<li><code>git inter HEAD~4</code> // изменение позиции последних 4 коммитов (интерактивный режим)</li>
					<li><code>git merge [namebranch]</code> // объединение ветки с текущей</li>
					<li><code>git cp [Commit1] [Commit2] [...]</code> // копирование отдельных коммитов на текущую ветку</li>
					<li>&nbsp;</li>
					<li><code>git push</code> // отправка изменений в оригинальный репозиторий</li>
					<li><code>git fetch</code> // извлечение изменений без объединения</li>
					<li><code>git pull</code> // извлечение изменений и объединение с текущей веткой</li>
				</ul>

				<p>Чтобы постоянно не вводить одни и те же команды, в файле настроек git настраиваются сокращения (alias).</p>
				<p>Для этого нужно открыть файл ~/.gitconfig и добавить в него сокращения команд. Например:</p>
<pre><code>[alias]
  com = commit -a -m
  coma = commit --amend -m
  del = reset --hard
  br = branch
  move = branch -f
  brd = branch -d
  go = checkout
  cp = cherry-pick
  cpa = cherry-pick --abort
  inter = rebase -i
  type = cat-file -t
  dump = cat-file -p
</code></pre>
				<p>Теперь набор команды, например, <code>git com 'Сообщение коммита'</code> будет аналогичен <code>git commit -a -m 'Сообщение коммита'</code>.</p>
			</li>

			<li data-title="Текущее состояние и история сохранений" class="content">
				<h3>Проверка текущего состояния:</h3>
				<pre><code>git status</code></pre>

				<h3>Получение истории сохранений:</h3>
				<pre><code>git log</code></pre>
				<p>Ключи для команды:</p>
				<ul>
					<li>Добавить изменения в индекс для последующего сохранения в репозитории:
<pre><code>git add .</code>
или
<code>git add [name]</code></pre>
					</li>
					<li>Отменить изменения:
<pre><code>git checkout -- .</code>
или
<code>git checkout -- [name]</code></pre>
					</li>
				</ul>

				<p>Самый краткий и удобный путь для добавления всех изменений в файлы текущего каталога и его подкаталоги &ndash; это использовать в качестве имени файла текущий каталог («.»).</p>
				<p>Но поскольку он добавляет всё, не лишним будет проверить состояние перед запуском <code>commit</code>, просто чтобы убедиться, что вы не добавили какой-то файл, который добавлять было не нужно.</p>

				<p>Оптимальным сочетанием для подробного отображения истории будет команда:</p>
				<pre><code>git log --abbrev-commit --decorate=short --date=local --graph</code></pre>

				<p>Показ коммитов со всех веток:</p>
				<pre><code>git log --graph --all</code></pre>
				<p>При использовании ключа <code>--graph</code> можно графически увидеть есть ли расхождения в ветках и какой коммит является предшественником расхождения.</p>
			</li>

			<li data-title="Индекс. Отслеживание новых файлов" class="content">
				<p>При добавлении файла в индекс мы сообщаем Git о необходимости отслеживания изменений в файле.</p>
				<p>Добавление 1 файла в индекс:</p>
				<pre><code>git add [имя файла]</code></pre>

				<p>Добавление всех файлов текущего каталога и его подкаталогов:</p>
				<pre><code>git add .</code></pre>

				<p>Для сохранения текущих изменений в репозитории используется команда <code>commit</code>.</p>
				<p>Не лишним будет проверить текущее состояние перед запуском <code>commit</code>, просто чтобы убедиться, что вы не добавили какой-то файл, который добавлять было не нужно.</p>

				<p>Если после добавления файла в индекс были новые изменения, то в коммит они добавлены не будут. Чтобы автоматически обновлять индекс файлов при коммите используется ключ <code>-a</code>:</p>
				<pre><code>git commit -a</code></pre>

				<p>Если новые изменения в индекс добавлять не нужно, можно откатиться к последним изменениям, добавленным в индекс.</p>
				<p>Для одного файла:</p>
				<pre><code>git checkout -- [name]</code></pre>

				<p>Для всех файлов:</p>
				<pre><code>git checkout -- .</code></pre>

				<p>Если нужно убрать новый файлы из индекса:</p>
				<pre><code>git reset HEAD [name]</code></pre>
				<p>или</p>
				<pre><code>git reset HEAD .</code></pre>

				<p>Отдельный шаг индексации в git позволяет продолжать вносить изменения в рабочий каталог, а затем, в момент, когда вы захотите взаимодействовать с версионным контролем, git позволит записать изменения в малых коммитах, которые фиксируют то, что вы сделали.</p>

				<p>При использовании команды <code>git commit</code> без параметров появится интерактивное окно редактора, где нужно будет ввести сообщение коммита.</p>
				<p>После ввода сообщения нужно нажать <code>Ctrl + X</code> &rarr; <code>Y</code> &rarr; <code>Enter</code> для сохранения и выхода из редактора</p>
			</li>

			<li data-title="Коммиты. Сохранение изменений в репозитории" class="content">
				<h3>Все действия с коммитами, особенно перемещение и слияние, следует производить крайне внимательно и осторожно. В противном случае изменения могут быть утеряны.</h3>
				<ul id="tabs-commit">
					<li data-title="Создание коммитов" class="content">
						<p>Коммиты создаются командой:</p>
						<pre><code>git commit -m 'Сообщение'</code></pre>
						<p>При этом все добавленные в индекс файлы будут сохранены. Все новые изменения, не попавшие в индекс, будут проигнорированы.</p>
						<p>Чтобы каждый раз не добавлять новые изменения в индекс, можно использовать ключ <code>-a</code>, который автоматически будет обновлять индекс. Не затрагивает новые файлы.</p>
						<pre><code>git commit -a -m 'Сообщение'</code></pre>
					</li>

					<li data-title="Внесение изменений в последний коммит" class="content">
						<p>Если после сделанного коммита появилась необходимость внести несколько мелких изменений и делать ради этого новый коммит не нужно, можно перезаписать последний коммит:</p>
						<pre><code>git commit --amend -a -m 'Сообщение коммита'</code></pre>
					</li>

					<li data-title="Переход по коммитам" class="content">
						<p>Перейти к конкретному коммиту можно двумя способами:</p>
						<ul>
							<li>Переход по хешу коммита.</li>
							<li>Переход по относительным ссылкам.</li>
						</ul>

						<p>Для перехода по хешу коммита достаточно знать первые 7 символов хеша (узнать их можно просмотрев историю):</p>
						<pre><code>git checkout [hash]</code></pre>

						<p>Для обозначения относительной ссылки используются символы «^» и «~». Символ <code>^</code> перемещает по дереву на 1 коммит, а символ <code>~</code> на указанное число коммитов.</p>
						<p>Например, если необходимо перейти на 4 коммита назад в ветке master, то можно выполнить:</p>
						<pre><code>git checkout master^^^^</code></pre>
						<p>или</p>
						<pre><code>git checkout master~4</code></pre>

						<p>Если после символа <code>^</code> указать номер, то будет осуществлён переход на номер родителя.</p>
						<p>Например, сразу после слияния двух веток у коммита появляются 2 родителя. По умолчанию переход происходит к первому родителю. Если нужно перейти ко второму, используется <code>^2</code>:</p>
						<pre><code>git checkout HEAD^2</code></pre>

						<p>Также эти относительные ссылки можно совмещать. Предположим, нужно вернуться на 1 коммит назад, после этого перейти на ветку второго родителя и затем вернуться ещё на 3 коммита назад:</p>
						<pre><code>git checkout HEAD~^2~3</code></pre>
					</li>

					<li data-title="Копирование изменений" class="content">
						<p>Когда не требуется сливать ветки целиком, можно из одной ветки перенести только нужные коммиты в другую.</p>

						<p>Речь идёт о возможности, позволяющей разработчику сказать: «Хочу, чтобы эти изменения были вот тут, а вот эти — вон там» и получить точные, правильные результаты, не теряя при этом гибкости разработки.</p>

						<p>В этом поможет команда <code>cherry-pick</code>:</p>
						<pre><code>git cherry-pick [Commit1] [Commit2] [...]</code></pre>
						<p>Это очень простой и прямолинейный способ сказать, что ты хочешь копировать несколько коммитов на место, где сейчас находишься (<code>HEAD</code>).</p>

						<p>Коммиты именно копируются, а не перемещаются. То есть, в дереве истории появляется 2 или более одинаковых коммитов, но в разных местах и сразными хешами.</p>
						<p>Если возникли конфликты, которые не удаётся решить, можно отменить копирование коммита командой:</p>
						<pre><code>git cherry-pick --abort</code></pre>
					</li>

					<li data-title="Изменение позиции и объединение коммитов" class="content">
						<p><code>cherry-pick</code> прекрасен, когда точно известно, какие коммиты нужны (и известны их точные хеши).</p>
						<p>Но как быть в случае, когда точно не известно какие коммиты нужны?</p>
						<p>К счастью, Git позаботился о таких ситуациях! Можно использовать интерактивный <code>rebase</code> для этого &ndash; лучший способ отобрать набор коммитов для <code>rebase</code>.</p>
						<p>Всё, что нужно для интерактивного <code>rebase</code> &ndash; это ключ <code>-i</code>.</p>
						<p>Если добавить этот ключ, Git откроет интерфейс просмотра того, какие коммиты готовы к копированию на цель <code>rebase</code> (<code>target</code>). Также показываются хеши коммитов и комментарии к ним, так что можно легко понять что к чему.</p>
						<p>После открытия окна интерактивного <code>rebase</code> есть три варианта для каждого коммита:</p>
						<ul>
							<li>Можно сменить положение коммита по порядку, переставив строчку с ним в редакторе.</li>
							<li>Можно «выкинуть» коммит из ребейза.</li>
							<li>Можно объединить изменения двух коммитов.</li>
						</ul>

						<p>Взять последние 4 коммита и выполнить в интерактивном режиме:</p>
						<pre><code>git rebase -i HEAD~4</code></pre>

						<p>Команды интерактивного режима:</p>
						<ul>
							<li><code>p, pick</code> &ndash; использовать коммит</li>
							<li><code>r, reword</code> &ndash; использовать коммит, но изменить сообщение коммита</li>
							<li><code>e, edit</code> &ndash; использовать коммит, но остановиться для внесения правок</li>
							<li><code>s, squash</code> &ndash; использовать коммит, но объединить его с предыдущим коммитом</li>
							<li><code>f, fixup</code> &ndash; как <code>squash</code>, но отбросить сообщение этого коммита</li>
							<li><code>x, exec</code> &ndash; выполнить команду (остаток строки) с помощью командной оболочки</li>
							<li><code>d, drop</code> &ndash; удалить коммит</li>
						</ul>
					</li>

					<li data-title="Удаление коммитов из локальной ветки" class="content">
						<p>В этом поможет команда <code>reset</code>. При получении ссылки на коммит (т.е. хеш, ветка или имя тега), команда <code>reset</code>:</p>
						<ul>
							<li>Перепишет текущую ветку, чтобы она указывала на нужный коммит.</li>
							<li>Опционально сбросит буферную зону для соответствия с указанным коммитом.</li>
							<li>Опционально сбросит рабочий каталог для соответствия с указанным коммитом.</li>
						</ul>

						<p>Предположим, что нужно удалить <strong>все</strong> коммиты, идущие после коммита <code>C7</code>.</p>
						<pre><code>git reset --hard C7</code></pre>

						<p>Параметр <code>--hard</code> указывает, что рабочий каталог должен быть обновлён в соответствии с новым <code>HEAD</code> ветки.</p>
					</li>

					<li data-title="Отмена коммитов" class="content">
						<p><code>Reset</code> отлично работает на локальных ветках, в локальных репозиториях. Но этот метод переписывания истории не сработает на удалённых ветках, которые используют другие пользователи.</p>
						<p>Чтобы отменить изменения и поделиться отменёнными изменениями с остальными, надо использовать <code>revert</code>. Эта команда сделает коммит, который удаляет изменения, сохранённые нежелательным коммитом:</p>
						<pre><code>git revert HEAD</code></pre>

						<p>При использовании <code>HEAD</code> отменяется самый последний произведённый коммит.</p>
						<p>Для отмены произвольного коммита, вместо <code>HEAD</code> нужно подставить хеш коммита из истории.</p>
					</li>
				</ul>
			</li>

			<li data-title="Метки (теги)" class="content">
				<p>Метки (теги) хороши для визуального выделения в дереве истории нужных коммитов, а также являются постоянными ссылками на нужное место. Например, номера версии проекта. По ним также можно перемещаться.</p>

				<h3>Переход по хэшу</h3>
				<p>Для перехода по хэшу коммита достаточно знать первые 7 символов хэша. Узнать их можно просмотрев всю историю:</p>
				<pre><code>git log --abbrev-commit --all</code></pre>
				<p>Узнав хэш необходимого сохранения переходим к нему:</p>
				<pre><code>git checkout [hash]</code></pre>

				<h3>Переход по тегу</h3>
				<p>Если у коммита установлен тег, можно перейти напосредственно по тегу:</p>
				<pre><code>git checkout [имя тега]</code></pre>
				<p>Создать тег можно командой:</p>
				<pre><code>git tag [имя тега]</code></pre>
				<p>Просмотреть список установленных тегов командой:</p>
				<pre><code>git tag</code></pre>

				<h3>Переход по относительной ссылке</h3>
				<p>Для обозначения относительной ссылки используются символы «^» и «~». Символ <code>^</code> перемещает по дереву на 1 коммит, а символ <code>~</code> на указанное число коммитов.</p>
				<p>Например, если необходимо перейти на 4 коммита назад в ветке master, то можно выполнить:</p>
				<pre><code>git checkout master^^^^</code></pre>
				<p>или</p>
				<pre><code>git checkout master~4</code></pre>

				<h3>Принудительное перемещение ветки</h3>
				<p>Чтобы принудительно переместить ветку на другой коммит, используется команда forcing`а:</p>
				<pre><code>git branch -f [имя ветки] [указатель]</code></pre>

				<h3>Примеры</h3>
				<p>Предположим, в проекте есть две ветки &ndash; <code>master</code> и <code>develop</code>.</p>
				<p>Общее количество коммитов &ndash; 15. <code>master</code> находится на коммите C12, <code>develop</code> находится на коммите C7, а текущее положение (<code>HEAD</code>) на коммите C3.</p>
				<p>Есть задача: не меняя текущего положения (не перемещая <code>HEAD</code>), ветку <code>master</code> переместить на последний коммит, а ветку <code>develop</code> на второй коммит. Затем изменить текущее положение на коммит C10.</p>
				<p>Наиболее простым и коротким решением будет:</p>
<pre><code>git branch -f master C15 // принудительно переместили master на последний коммит
git branch -f develop HEAD^ // сместили ветку develop относительно HEAD на 1 коммит назад
git checkout C10 // перестили HEAD на C10</code></pre>
			</div>
		</section>

		<section>
			<span id="item8"></span>
			<a href="#item8" id="open-item8">Git внутри: поиск файлов через каталог .git</a>
			<a href="#items" id="close-item8">Git внутри: поиск файлов через каталог .git</a>
			<div class="content">
				<p>Поиск последнего коммита:</p>
				<pre><code>git log -1</code></pre>
				<p>Вывод последнего коммита:</p>
<pre><code>git cat-file -t [hash]
git cat-file -p [hash]</code></pre>

				<p>Это вывод объекта коммита, который находится во главе ветки.</p>

				<h3>Удаление метки и коммитов, на которые он ссылался:</h3>
				<pre><code>git tag -d [имя тега]</code></pre>
			</li>

			<li data-title="Работа с ветками" class="content">
				<ul id="tabs-branch">
					<li data-title="Список веток" class="content">
						<p>Просмотр локальных веток:</p>
						<pre><code>git branch</code></pre>

						<p>Просмотр всех удалённых, и локальных веток:</p>
						<pre><code>git branch -a</code></pre>
					</li>

					<li data-title="Создание и переключение между ветками" class="content">
						<p>Создание и переключение на новую ветку:</p>
						<pre><code>git checkout -b [имя ветки]</code></pre>
						<p>или</p>
<pre><code>git branch [имя ветки] // создание новой ветки
git checkout [имя ветки] // переключение на ветку</code></pre>
					</li>

					<li data-title="Принудительное перемещение ветки" class="content">
						<p>Чтобы принудительно переместить ветку на другой коммит, используется команда forcing`а:</p>
						<pre><code>git branch -f [имя ветки] [указатель]</code></pre>
						<p>Перемещаемая ветка и текущее положение не должны совпадать. Если совпадают, то сначала нужно перейти в состояние отделённого <code>HEAD</code>, а потом переместить ветку.</p>
						<p>После перемещения ветки несвязаные коммиты удаляются.</p>

						<p><strong>Примеры</strong></p>
						<p>Предположим, в проекте есть две ветки &ndash; <code>master</code> и <code>develop</code>.</p>
						<p>Общее количество коммитов &ndash; 15. <code>master</code> находится на коммите C12, <code>develop</code> находится на коммите C7, а текущее положение (<code>HEAD</code>) на коммите C3.</p>
						<p>Есть задача: не меняя текущего положения (не перемещая <code>HEAD</code>), ветку <code>master</code> переместить на последний коммит, а ветку <code>develop</code> на второй коммит. Затем изменить текущее положение на коммит C10.</p>
						<p>Наиболее простым и коротким решением будет:</p>
<pre><code>git branch -f master C15 // принудительно переместили master на последний коммит
git branch -f develop HEAD^ // сместили ветку develop относительно HEAD на 1 коммит назад
git checkout C10 // перестили HEAD на C10</code></pre>
					</li>

					<li data-title="Слияние веток" class="content">
						<p>Слияние переносит изменения из двух веток в одну. Например, нужно слить ветку <code>master</code> с веткой <code>develop</code>:</p>
<pre><code>git checkout develop // переход на ветку develop
git merge master // слияние веток
git log --graph --all // просмотр изменений</code></pre>

						<p>Путём периодического слияния веток можно переносить любые изменения и поддерживать совместимость изменений ветки с изменениями в основной ветке.</p>
						<p>Однако, это делает графики коммитов действительно уродливыми.</p>
					</li>

					<li data-title="Перебазирование как альтернатива слиянию" class="content">
						<pre><code>git rebase [какую ветку] [на какую ветку]</code></pre>
						<p>Использование команды <code>rebase</code> вместо команды <code>merge</code>:</p>
<pre><code>git rebase master develop
git log --graph --all</code></pre>

						<p>Конечный результат перебазирования очень похож на результат слияния. Ветка <code>develop</code> в настоящее время содержит все свои изменения, а также все изменения ветки <code>master</code>. Однако, дерево коммитов значительно отличается.</p>
						<p>Дерево коммитов ветки <code>develop</code> было переписано таким образом, что ветка <code>master</code> является частью истории коммитов. Это делает цепь коммитов линейной и гораздо более читабельной.</p>
					</li>

					<li data-title="Когда использовать перебазирование, а когда слияние?" class="content">
						<p>В среде разработчиков существует огромное количество дебатов около merging и rebasing.</p>
						<p>Ниже приведены основные за / против метода rebasing:</p>

						<ul>
							<li>За:
								<ul>
									<li>Rebasing делает дерево коммитов более чистым и читабельным, потому что всё представляется единой прямой линией.</li>
								</ul>
							</li>
							<li>Против:
								<ul>
									<li>Метод rebasing явно изменяет историю коммитов в дереве.</li>
								</ul>
							</li>
						</ul>

						<p>Например, коммит <code>C1</code> может быть перебазирован после <code>C3</code>. Соответственно, в дереве работа над <code>C1'</code> будет отображаться как идущая после <code>C3</code>, хотя на самом деле она была выполнена раньше.</p>

						<p>Некоторые разработчики любят сохранять историю и предпочитают слияние (merging). Другие предпочитают иметь чистое дерево коммитов и пользуются перебазировкой (rebasing). Всё зависит от ваших предпочтений и вкусов.</p>

						<p>Общие рекомендации. Не используйте перебазирование:</p>
						<ul>
							<li>Если ветка является публичной и расшаренной. Переписывание общих веток будет мешать работе других членов команды.</li>
							<li>Когда важна точная история коммитов ветки (так как команда <code>rebase</code> переписывает историю коммитов).</li>
						</ul>

						<p>Учитывая приведённые выше рекомендации, я предпочитаю использовать <code>rebase</code> для кратковременных, локальных веток, а слияние для веток в публичном репозитории.</p>
					</li>
				</ul>
			</li>

			<li data-title="Удалённые репозитории" class="content">
				<ul id="tabs-remote">
					<li data-title="Клонирование репозиториев" class="content">
						<p>Перед клонированием нужно находиться в рабочем каталоге, куда будет происходить клонирование репозитория.</p>
						<p>Для проверки, можно узнать текущее месторасположение:</p>
<pre><code>pwd // показывает полный путь к текущему каталогу
ls // показывает содержимое каталога</code></pre>

						<p>Источником клона может служить как удалённый репозиторий, так и локальный каталог. Если не использовать параметр имени клона, будет создано имя источника.</p>

						<p>Создание клона:</p>
						<pre><code>git clone [источник] [имя копии]</code></pre>

						<p>Например, сделать клон репозитория <a href="https://github.com/AleksiMagner/git-tutor" target="_blank"><code>https://github.com/AleksiMagner/git-tutor</code></a>:</p>
						<pre><code>git clone git@github.com:AleksiMagner/git-tutor.git</code></pre>
						<p>Сделать клон локальной папки <code>work</code>:</p>
						<pre><code>git clone work work_clone</code></pre>
						<p>После создания клона необходимо войти в каталог:</p>
<pre><code>cd git-tutor
или
cd work</code></pre>

						<p>Находясь в клоне:</p>
<pre><code>git remote // удалённое имя оригинального репозитория. По умолчанию origin
git remote show origin // более подробная информация об удалённом репозитории
git branch // список локальных веток клона
git branch -a // список и удалённых, и локальных веток</code></pre>

						<p>Git выводит все коммиты в оригинальный репозиторий, но ветки в удалённом репозитории не рассматриваются как локальные. Если мы хотим собственную ветку, мы должны сами её создать.</p>
					</li>

					<li data-title="Отслеживание удалённых веток" class="content">
						<p>Вы можете сказать любой из веток, чтобы она отслеживала удалённую ветку, например, <code>origin/master</code>. Но лучше всего локальную ветку называть также, как и удалённую. В противном случае не гарантируется полная совместимость при обновлении данных.</p>

						<p>Если имена локальной и удалённой ветки совпадают, то ветки автоматически будут настроены на <code>pull</code> и <code>push</code>. Команду <code>git push</code> в этом случае можно использовать без параметров.</p>

						<p>В противном случае локальная ветка будет настроена только на <code>pull</code>, а при <code>push</code> придётся указывать пункт назначения напрямую в параметрах.</p>

						<p>Предположим, в оригинальном репозитории создана ветка <code>release</code>. Но при клонировании перенесётся только ветка <code>master</code>.</p>
						<p>Чтобы сделать такую же ветку в клоне с отслеживанием оригинальной ветки:</p>
						<pre><code>git branch -t release origin/release</code></pre>

						<p>Чтобы отменить отслеживание, используется ключ <code>--unset-upstream</code>:</p>
						<pre><code>git branch --unset-upstream [ветка]</code></pre>
					</li>

					<li data-title="Nested accordion Third tab" class="content">
					</li>

					<li data-title="Nested accordion Third tab" class="content">
					</li>

					<li data-title="Nested accordion Third tab" class="content">
					</li>

					<li data-title="Nested accordion Third tab" class="content">
					</li>

					<li data-title="Nested accordion Third tab" class="content">
					</li>

					<li data-title="Nested accordion Third tab" class="content">
					</li>

					<li data-title="Nested accordion Third tab" class="content">
					</li>

					<li data-title="Nested accordion Third tab" class="content">
					</li>

					<li data-title="Nested accordion Third tab" class="content">
					</li>

					<li data-title="Nested accordion Third tab" class="content">
					</li>
				</ul>
Скачивание изменений с удалённого репозитория
Команда fetch выполняет две и только две основные операции. А именно:
	* связывается с указанным удалённым репозиторием и забирает все те данные проекта, которых у вас ещё нет, при этом...
	* у вас должны появиться ссылки на все ветки из этого удалённого репозитория (например, origin/master).

Фактически, fetch синхронизирует локальное представление удалённых репозиториев с тем, что является актуальным на текущий момент времени.

Чего fetch не делает
Важно отметить, что команда fetch забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент.

Важно это помнить и понимать, потому что многие разработчики думают, что, запустив команду fetch, они приведут всю свою локальную работу к такому же виду, как и на удалённом репозитории. Команда всего лишь скачивает все необходимые данные, но вам потребуется вручную слить эти данные с вашими, когда вы будете готовы.

Если указать пункт назначения в команде, например так:
git fetch origin foo

Git отправится в ветку foo на удалённом репозитории, соберёт все коммиты, которые не присутствуют локально, и затем поместит их в локальную ветку под названием origin/foo. При этом локальная ветка foo не будет затронута.

Если вы уверены в том, что хотите закачать коммиты прямиком в вашу локальную ветку, тогда можно явно указать источник и получатель через двоеточние. Вы можете воспользоваться таким приёмом лишь для ветки, на которой вы не находитесь в настоящий момент.
git fetch origin [источник]:[получатель]

[источник] - это место на удалённом репозитории, а [получатель] - место в локальном репозитории, в который следует помещать коммиты. Аргументы в точности до наоборот повторяют push.

Разработчики редко используют такой подход на практике. Целью демонстрации этой возможности было показать, насколько схожи концептуально fetch и push. Их отличие лишь в направлении переноса данных.

Если команда fetch выполняется без аргументов, она скачивает все-все коммиты с удалённого репозитория и помещает их в соответствующие удалённо-локальные ветки в локальном репозитории...


Скачивание изменений с удалённого репозитория и объединение
Процедура скачивания (fetching) изменений с удалённой ветки и объединения (merging) настолько частая и распространённая, что Git предоставляет вместо двух команд - одну! Эта команда - pull.

То есть, следующие команды эквивалентны:
git fetch
git merge origin/master

и

git pull

Аргументы команды pull используются такие же, как и у fetch.
Следующие команды эквивалентны:
git pull origin foo
и
git fetch origin foo
git merge origin/foo

или

git pull origin bar~1:bugFix
и
git fetch origin bar~1:bugFix
git merge bugFix


Отправка изменений на удалённый репозиторий
Команда push отвечает за загрузку ваших изменений в указанный удалённый репозиторий, а также включение ваших коммитов в состав удалённого репозитория.
git push [удалённый_репозиторий] [пункт_назначения]

Если выполнять команду без параметров (git push), будут отправленны все коммиты с текущей ветки на отслеживаемую ветку.

Допустим, что мы выполняем такую команду:
git push origin master

Для Git это означает:

Перейди в ветку с именем «master» в моём локальном репозитории, возьми все коммиты и затем перейди на ветку «master» на удалённом репозитории «origin». На эту удалённую ветку скопируй все отсутствующие коммиты, которые есть у меня, и скажи, когда ты закончишь.

Указывая master в качестве аргумента [пункт_назначения], мы тем самым говорим Git откуда будут приходить и уходить наши коммиты. Аргумент [пункт_назначения] - это синхронизация между двумя репозиториями.

Имейте в виду, что с тех пор, как мы сказали Git всё, что ему необходимо (указав оба аргумента), абсолютно всё равно, где находится HEAD при выполнении команды!

Если [пункт_назначения] не указан, то положение HEAD должно быть на целевой ветке.

В том случае, когда необходимо разделить источник и получатель аргумента [пункт_назначения], соедините их вместе, используя двоеточие:
git push origin [источник]:[получатель]

Пример:
git push origin foo^:develop

Если ветка [получатель] отсутствует в репозитории, она будет создана сразу с отслеживанием.


Расхождение истории
Сложности возникают тогда, когда история репозиториев расходится. Давайте посмотрим на пример...

Представьте себе, вы склонировали репозиторий в понедельник и начали разрабатывать какую-то новую и уникальную часть проекта. В пятницу вечером вы наконец-то готовы опубликовать ваши изменения.

Но, о нет! Ваш коллега в течение недели написал кучу кода, который делает все ваши наработки устарелыми. Этот код был также закоммичен и опубликован на общедоступном удалённом репозитории, поэтому теперь ваш код базируется на устаревшей версии проекта и более не уместен.

В этом случае использование команды push является сомнительным.

Как поведёт себя команда push, если вы её выполните? Может быть, она изменит удалённый репозиторий и вернёт всё к тому состоянию, которое было в понедельник? А может, команда попробует добавить ваш код, не удаляя при этом новый? Или же она проигнорирует ваши изменения, так как они уже устарели?

По причине того, что в данной ситуации (когда история расходится) слишком много двусмысленностей и неопределённостей, Git не даст вам закачать (push) ваши изменения. Он будет принуждать вас включить в состав своей работы все те последние наработки и изменения, которые находятся на удалённом репозитории.

Как же разрешить данную ситуацию? Всё очень просто! Всё, что вам нужно - перебазировать свою работу на самую последнюю версию удалённой ветки.

Существует множество способов сделать это, но наиболее простой способ «сдвинуть» свои наработки - через перебазировку или rebasing. Давайте посмотрим, как это выглядит.
git fetch
git rebase origin/master
git push

Мы только что обновили наш локальный репозиторий средствами fetch. Ещё мы перебазировали наши наработки, чтобы они отражали все изменения с удалённого репозитория, и опубликовали их с помощью push.

Или более короткий аналог:
git pull --rebase
git push

А есть ещё какие-либо варианты обновить мои наработки к тому моменту, как удалённый репозиторий был обновлён? Конечно есть! Давайте попробуем это сделать в этот раз с помощью команды merge.

Несмотря на то, что merge не передвигает ваши наработки (а всего лишь создаёт новый коммит, в котором Ваши и удалённые изменения объединены), этот способ помогает указать Git`у на то, что вы собираетесь включить в состав ваших наработок все изменения с удалённого репозитория.

Это значит, что ваш коммит отразится на всех коммитах удалённой ветки, поскольку удалённая ветка является предком вашей собственной локальной ветки.
git fetch
git merge origin/master
git push

Мы обновили наш локальный репозиторий с помощью fetch, объединили ваши новые наработки с наработками команды (чтобы отразить изменения в удалённом репозитории) и затем опубликовали их с помощью push.

Или более короткий аналог:
git pull
git push

Среди разработчиков, вовлечённых в большой проект, довольно распространён приём — выполнять всю свою работу на отдельных ветках (вне master). А затем, как только работа выполнена, разработчик интегрирует всё, что было им сделано.

Ряд разработчиков делают push и pull лишь на локальную ветку master - таким образом ветка master всегда синхронизирована с удалённым репозиторием (origin/master).
			</li>

			<li data-title="Чистый репозиторий" class="content">
				<p>Чистые репозитории (без рабочих каталогов) обычно используются для расшаривания.</p>
				<p>Обычный git-репозиторий подразумевает, что вы будете использовать его как рабочую директорию, поэтому вместе с файлами проекта в актуальной версии, git хранит все служебные, «чисто-репозиториевские» файлы в поддиректории <code>.git</code>.</p>
				<p>В удалённых репозиториях нет смысла хранить рабочие файлы на диске (как это делается в рабочих копиях), а всё что им действительно нужно — это дельты изменений и другие бинарные данные репозитория.</p>
				<p>Вот это и есть «чистый репозиторий».</p>
				<p>Перейти в каталог, где находится репозиторий, с которого необходимо сделать чистый репозиторий и выполнить:</p>
				<pre><code>git clone --bare [имя репо] [имя репо].git // создаст чистый репозиторий на основе [имя репо]</code></pre>

				<p>Как правило, репозитории, оканчивающиеся на <code>.git</code> являются чистыми репозиториями.</p>
				<p>В репозитории <code>[имя репо].git</code> нет рабочего каталога. По сути, это есть не что иное, как каталог <code>.git</code> нечистого репозитория.</p>

				<h3>Добавление чистого репозитория к оригинальному в качестве удалённого репозитория</h3>
				<p>Перейти в каталог оригинального репозитория и выполнить:</p>
				<pre><code>git remote add shared ../repo.git</code></pre>
				<p>где <code>shared</code> &ndash; имя удалённого репо, <code>../repo.git</code> &ndash; путь к нему</p>

				<h3>Отправка изменений на общий репозиторий</h3>
				<p>Общим называется репозиторий, получающий отправленные нами изменения.</p>
				<pre><code>git push shared master // shared это имя удалённого репо, master это ветка на которую отправить</code></pre>

				<h3>Извлечение изменений из общего репозитория</h3>
				<pre><code>git branch --track shared master // добавил ветку shared, которая отслеживает master на общем репо</code></pre>
				<pre><code>git pull shared master // получение и слитие данных из репо shared, ветка master</code></pre>
			</li>

			<li data-title="Git внутри: поиск файлов через каталог .git" class="content">
				<p>Поиск последнего коммита:</p>
				<pre><code>git log -1</code></pre>
				<p>Вывод последнего коммита:</p>
<pre><code>git cat-file -t [hash]
git cat-file -p [hash]</code></pre>

				<p>Это вывод объекта коммита, который находится во главе ветки.</p>

				<p>Поиск дерева:</p>
				<pre><code>git cat-file -p [treehash]</code></pre>
				<p>Вывод каталога:</p>
				<pre><code>git cat-file -p [cathash]</code></pre>
				<p>Вывод файла:</p>
				<pre><code>git cat-file -p [filehash]</code></pre>
			</li>

			<li data-title="Настройка Git сервера для совместного использования репозиториев" class="content">
				<p>Перейти в рабочую директорию.</p>
				<p>Запуск git сервера:</p>
				<pre><code>git daemon --verbose --export-all --base-path=.</code></pre>

				<p>Открыть отдельное окно терминала и перейти в рабочую дерикторию.</p>
<pre><code>git clone git://localhost/repo.git network_repo
cd network_repo
ls</code></pre>

				<p>Должна появиться копия проекта repo, которая хранится в чистом репозитори repo.git</p>

				<h3>Отправка в Git Daemon</h3>
				<p>Если вы хотите совершить отправку в репозиторий <code>Git Daemon</code>, добавьте метку <code>--enable=receive-pack</code> к команде <code>git daemon</code>. Будьте осторожны, этот сервер не производит аутентификацию, поэтому любой может отправлять изменения в ваш репозиторий.</p>
			</li>

			<li data-title="Ресурсы в помощь" class="content">
				<p>Есть четыре способа открыть страницу руководства по любой команде Git:</p>
				<ul>
					<li><code>man git [команда]</code></li>
					<li><code>man git-[команда]</code></li>
					<li><code>git help [команда]</code></li>
					<li><code>git [команда] --help</code></li>
				</ul>

				<p>Справка по Git: <code>git --help</code></p>
				<p>Справка по конфигурации Git: <code>man git config</code></p>

				<p><a href="https://githowto.com/ru" target="_blank">Git How To</a> &ndash; интерактивный тур, который познакомит с основами Git.</p>
				<p><a href="https://learngitbranching.js.org/" target="_blank">LearnGitBranching</a> &ndash; интерактивное онлайн-приложение, помогает новичкам постичь мощные возможности ветвления и работы с Git.</p>
				<p><a href="https://habr.com/ru/post/106912/" target="_blank">Удачная модель ветвления для Git</a> &ndash; используется при разработке проектов.</p>
				<p><a href="https://git-scm.com/book/ru/v2" target="_blank">Книга Pro Git на русском</a></p>
				<p><a href="https://learngitbranching.js.org/" target="_blank">LearnGitBranching</a> &ndash; интерактивное онлайн-приложение, помогает новичкам постичь мощные возможности ветвления и работы с git.</p>
				<p><a href="https://habr.com/ru/post/106912/" target="_blank">Удачная модель ветвления для Git</a> &ndash; используется при разработке проектов.</p>
				<p><a href="http://gitignore.io/" target="_blank">gitignore</a> &ndash; облегчает создание файлов <code>.gitignore</code> для проектов.</p>
			</li>
		</ul>
	</main>

 <script src="vanilla.tabs.js"></script>
 <script src="tabs.js"></script>

</body>
</html>