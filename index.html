<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<title>Руководство по работе с Git</title>
	<link rel="stylesheet" href="style.css">
</head>
<body>
	<main>
		<h1>Руководство по работе с Git</h1>
		<span id="items"></span>
		<section>
			<span id="item1"></span>
			<a href="#item1" id="open-item1">Часто используемые команды</a>
			<a href="#items" id="close-item1">Часто используемые команды</a>
			<div class="content">
<pre><code>git add . // добавление всех изменений в индекс
git com 'Комментарий' // добавление всех изменений в индекс (если файл до этого был уже в индексе) и сохранение (коммит)
git coma 'Сообщение коммита' // изменение последнего коммита
git del [hash] // удаление коммитов из истории
git st // текущий статус
git hist // краткая история изменений
git hist-f // полная история изменений
git go -b [namebranch] // создание новой ветки и переключение на неё
git go [name] // переключение на новую ветку, возврат к исходной версии файла
git branch -d [namebranch] // удаление ветки
git push // отправка изменений в оригинальный репозиторий
git pull // получение последней актуальной версии с оригинального репозитория</code></pre>
			</div>
		</section>

		<section>
			<span id="item2"></span>
			<a href="#item2" id="open-item2">Изменение файлов и отмена изменений</a>
			<a href="#items" id="close-item2">Изменение файлов и отмена изменений</a>
			<div class="content">
				<h3>До внесения изменений в индекс</h3>
				<p>После внесения изменений в файлы репозитория можно сделать следующее:</p>
				<ul>
					<li>Добавить изменения в индекс для последующего сохранения в репозитории:
<pre><code>git add .</code>
или
<code>git add [name]</code></pre>
					</li>
					<li>Отменить изменения:
<pre><code>git checkout -- .</code>
или
<code>git checkout -- [name]</code></pre>
					</li>
				</ul>

				<p>Самый краткий и удобный путь для добавления всех изменений в файлы текущего каталога и его подкаталоги &ndash; это использовать в качестве имени файла текущий каталог («.»).</p>
				<p>Но поскольку он добавляет всё, не лишним будет проверить состояние перед запуском <code>commit</code>, просто чтобы убедиться, что вы не добавили какой-то файл, который добавлять было не нужно.</p>

				<h3>После внесения изменений в индекс</h3>
				<ul>
					<li>Сделать сохранение проиндексированных изменений в репозитории:
						<pre><code>git commit -m 'Сообщение коммита'</code></pre>
					</li>
					<li>Убрать изменённые файлы из индекса:
<pre><code>git reset HEAD [name]</code>
или
<code>git reset HEAD .</code></pre>
					</li>
				</ul>

				<p>Отдельный шаг индексации в git позволяет продолжать вносить изменения в рабочий каталог, а затем, в момент, когда вы захотите взаимодействовать с версионным контролем, git позволит записать изменения в малых коммитах, которые фиксируют то, что вы сделали.</p>

				<p>При использовании команды <code>git commit</code> без параметров появится интерактивное окно редактора, где нужно будет ввести сообщение коммита.</p>
				<p>После ввода сообщения нужно нажать <code>Ctrl + X</code> &rarr; <code>Y</code> &rarr; <code>Enter</code> для сохранения и выхода из редактора</p>
			</div>
		</section>

		<section>
			<span id="item3"></span>
			<a href="#item3" id="open-item3">Изменение и удаление тегов и коммитов</a>
			<a href="#items" id="close-item3">Изменение и удаление тегов и коммитов</a>
			<div class="content">
				<h3>Внесение изменений в коммиты</h3>
				<p>Если вдруг после сделанного коммита появилась необходимость внести несколько мелких изменений и делать ради этого новый коммит не нужно, можно перезаписать последний коммит.</p>
				<p>Добавляем в индекс новые изменения после последнего сделанного коммита:</p>
				<pre><code>git add [имя файла]</code></pre>
				<p>Заменяем последний коммит на новый:</p>
				<pre><code>git commit --amend -m 'Сообщение коммита'</code></pre>

				<p>Этого же эффекта можно достичь путём сброса последнего коммита в ветке, и повторного коммита новых изменений.</p>

				<h3>Отмена коммитов</h3>
				<p>Чтобы сделать коммит, который удаляет изменения, сохраненные нежелательным коммитом:</p>
				<pre><code>git revert HEAD</code></pre>

				<p>При использовании <code>HEAD</code> отменяется самый последний произведённый коммит.</p>
				<p>Для отмены произвольного коммита, вместо <code>HEAD</code> нужно подставить хэш коммита из истории.</p>

				<h3>Удаление коммитов из ветки</h3>
				<p>В этом поможет команда <code>reset</code>. При получении ссылки на коммит (т.е. хэш, ветка или имя тега), команда <code>reset</code>…</p>
				<ul>
					<li>Перепишет текущую ветку, чтобы она указывала на нужный коммит;</li>
					<li>Опционально сбросит буферную зону для соответствия с указанным коммитом;</li>
					<li>Опционально сбросит рабочий каталог для соответствия с указанным коммитом.</li>
				</ul>

				<p>Но прежде чем удалить коммиты, отметим последний коммит тегом, чтобы потом можно было его найти:</p>
				<pre><code>git tag oops</code></pre>

				<p>Предположим, что нужно удалить все коммиты, идущие после коммита с тегом <code>v1</code>.</p>
				<pre><code>git reset --hard v1</code></pre>

				<p>Если тега нет, можно использовать хэш-значение.</p>
				<p>Параметр <code>--hard</code> указывает, что рабочий каталог должен быть обновлён в соответствии с новым <code>HEAD</code> ветки.</p>

				<p>Сам ошибочный тег <code>oops</code> остался в репозитории. Увидеть в истории можно командой <code>git log --all</code>.</p>
				<p>Коммиты, на которые нет ссылок, остаются в репозитории до тех пор, пока не будет запущен сборщик мусора.</p>
				<p>Сброс в локальных ветках, как правило, безопасен. Последствия любой «аварии», как правило, можно восстановить простым сбросом с помощью нужного коммита.</p>
				<p>Однако, если ветка «расшарена» на удалённых репозиториях, сброс может сбить с толку других пользователей ветки.</p>

				<h3>Удаление тега oops (уборка)</h3>
				<p>Тег <code>oops</code> свою функцию выполнил. Чтобы удалить его и коммиты, на которые он ссылался, воспользуемся сборщиком мусора:</p>
				<pre><code>git tag -d oops</code></pre>
			</div>
		</section>

		<section>
			<span id="item4"></span>
			<a href="#item4" id="open-item4">Текущее состояние и история</a>
			<a href="#items" id="close-item4">Текущее состояние и история</a>
			<div class="content">
				<p>Проверка текущего состояния:</p>
				<pre><code>git status</code></pre>

				<p>Получение списка произведённых изменений (история):</p>
				<pre><code>git log</code></pre>
				<p>Ключи для команды:</p>
				<ul>
					<li><code>--format=[param]</code> &ndash; формат отображения истории
						<ul>
							<li><code>oneline</code> &ndash; однострочное отображение. Хэш коммита, сообщение</li>
							<li><code>short</code> &ndash; хэш коммита, автор, сообщение</li>
							<li><code>medium</code> &ndash; хэш коммита, автор, дата, сообщение. Стандартное отображение</li>
						</ul>
					</li>
					<li><code>--abbrev-commit</code> &ndash; сокращает хэш коммита для лучшей читаемости</li>
					<li><code>--oneline</code> &ndash; однострочное отображение истории с сокращением хэша коммитов. Аналог <code>--format=oneline --abbrev-commit</code></li>
					<li><code>-2</code> &ndash; последние два коммита</li>
					<li><code>--after='5 minutes ago'</code> &ndash; показать коммиты, созданные позже, чем указанная дата (5 минут назад)</li>
					<li><code>--before='5 minutes ago'</code> &ndash; показать коммиты, созданные раньше, чем указанная дата (5 минут назад)</li>
					<li><code>--author=AleksiMagner</code> &ndash; показать только коммиты указанного автора (AleksiMagner)</li>
					<li><code>--graph</code> &ndash; отображает дерево коммитов в виде ASCII-графика</li>
					<li><code>--date=local</code> &ndash; отображать дату в локальном формате</li>
					<li><code>--decorate=short</code> &ndash; дополнения коммита («головы» веток или теги)</li>
					<li><code>--all</code> &ndash; отображение всех коммитов со всех веток сразу</li>
				</ul>
				<p>Руководство по команде:</p>
				<pre><code>man git log</code></pre>
				<p>Оптимальным сочетанием для короткого отображения истории будет команда:</p>
				<pre><code>git log --oneline --decorate=short --graph</code></pre>

				<p>Оптимальным сочетанием для подробного отображения истории будет команда:</p>
				<pre><code>git log --abbrev-commit --decorate=short --date=local --graph</code></pre>

				<p>Показ коммитов со всех веток:</p>
				<pre><code>git log --graph --all</code></pre>
				<p>При использовании ключа <code>--graph</code> можно графически увидеть есть ли расхождения в ветках и какой коммит является предшественником расхождения.</p>
			</div>
		</section>

		<section>
			<span id="item5"></span>
			<a href="#item5" id="open-item5">Alias (сокращения)</a>
			<a href="#items" id="close-item5">Alias (сокращения)</a>
			<div class="content">
				<p>Бывает неудобно постоянно вводить одни и те же команды. Можно настроить сокращения в файле настроек git.</p>
				<p>Для этого нужно открыть файл ~/.gitconfig и добавить в него сокращения команд. Например:</p>
<pre><code>[alias]
  com = commit -a -m
  coma = commit --amend -m
  del = reset --hard
  hist = log --oneline --decorate=short --graph
  hist-f = log --abbrev-commit --decorate=short --date=local --graph
  st = status
  go = checkout
  type = cat-file -t
  dump = cat-file -p
</code></pre>
				<p>Теперь набор команды, например, <code>git com 'Сообщение коммита'</code> будет аналогичен <code>git commit -a -m 'Сообщение коммита'</code>.</p>
			</div>
		</section>

		<section>
			<span id="item6"></span>
			<a href="#item6" id="open-item6">Переход по коммитам и работа с тегами</a>
			<a href="#items" id="close-item6">Переход по коммитам и работа с тегами</a>
			<div class="content">
				<p>Получить доступ к сохранённой версии файла можно трёмя способами:</p>
				<ul>
					<li>Переход по хэшу коммита;</li>
					<li>Переход по тегу;</li>
					<li>Переход по относительным ссылкам.</li>
				</ul>

				<h3>Переход по хэшу</h3>
				<p>Для перехода по хэшу коммита достаточно знать первые 7 символов хэша. Узнать их можно просмотрев всю историю:</p>
				<pre><code>git log --abbrev-commit --all</code></pre>
				<p>Узнав хэш необходимого сохранения переходим к нему:</p>
				<pre><code>git checkout [hash]</code></pre>

				<h3>Переход по тегу</h3>
				<p>Если у коммита установлен тег, можно перейти напосредственно по тегу:</p>
				<pre><code>git checkout [имя тега]</code></pre>
				<p>Создать тег можно командой:</p>
				<pre><code>git tag [имя тега]</code></pre>
				<p>Просмотреть список установленных тегов командой:</p>
				<pre><code>git tag</code></pre>

				<h3>Переход по относительной ссылке</h3>
				<p>Для обозначения относительной ссылки используется символ «^». Один такой символ перемещает по дереву на 1 коммит.</p>
				<p>Например, если необходимо перейти на 3 коммита назад в ветке master:</p>
				<pre><code>git checkout master^^^</code></pre>
			</div>
		</section>

		<section>
			<span id="item7"></span>
			<a href="#item7" id="open-item7">Перемещение файлов в пределах репозитория</a>
			<a href="#items" id="close-item7">Перемещение файлов в пределах репозитория</a>
			<div class="content">
				<p>Предположим, нужно переместить файл <code>style.css</code> в каталог <code>css</code>:</p>
<pre><code>mkdir css // создали каталог
git mv style.css css // переместили файл
</code></pre>
				<p>Перемещая файлы с помощью git, мы информируем git о 2 вещах:</p>
				<ul>
					<li>Что файл <code>style.css</code> был удалён.</li>
					<li>Что файл <code>css/style.css</code> был создан.</li>
				</ul>
				<p>Оба эти факта сразу же проиндексированы и готовы к коммиту.</p>

				<p>Проделав немного больше работы, можно достичь того же результата и другим способом:</p>
<pre><code>mkdir lib
mv style.css css // перемещение файла посредством командной строки операционной системы
git add css/style.css
git rm style.css
</code></pre>
			</div>
		</section>

		<section>
			<span id="item8"></span>
			<a href="#item8" id="open-item8">Git внутри: поиск файлов через каталог .git</a>
			<a href="#items" id="close-item8">Git внутри: поиск файлов через каталог .git</a>
			<div class="content">
				<p>Поиск последнего коммита:</p>
				<pre><code>git log -1</code></pre>
				<p>Вывод последнего коммита:</p>
<pre><code>git cat-file -t [hash]
git cat-file -p [hash]</code></pre>

				<p>Это вывод объекта коммита, который находится во главе ветки.</p>

				<p>Поиск дерева:</p>
				<pre><code>git cat-file -p [treehash]</code></pre>
				<p>Вывод каталога:</p>
				<pre><code>git cat-file -p [cathash]</code></pre>
				<p>Вывод файла:</p>
				<pre><code>git cat-file -p [filehash]</code></pre>
			</div>
		</section>

		<section>
			<span id="item9"></span>
			<a href="#item9" id="open-item9">Работа с ветками</a>
			<a href="#items" id="close-item9">Работа с ветками</a>
			<div class="content">
				<p>Просмотр локальных веток:</p>
				<pre><code>git branch</code></pre>

				<p>Просмотр всех удалённых, и локальных веток:</p>
				<pre><code>git branch -a</code></pre>

				<p>Создание и переключение на новую ветку:</p>
				<pre><code>git checkout -b [имя ветки]</code></pre>
				<p>или</p>
<pre><code>git branch [имя ветки] // создание новой ветки
git checkout [имя ветки] // переключение на ветку</code></pre>

				<h3>Добавление локальной ветки, которая отслеживает удалённую ветку.</h3>
				<p>Предположим, в оригинальном репозитории создана ветка <code>release</code>. Но при клонировании перенесётся только ветка <code>master</code>.</p>
				<p>Чтобы сделать такую же ветку в клоне с отслеживанием оригинальной ветки:</p>
				<pre><code>git branch --track release origin/release</code></pre>

				<h3>Слияние веток</h3>
				<p>Слияние переносит изменения из двух веток в одну. Например, нужно слить ветку <code>master</code> с веткой <code>develop</code>:</p>
<pre><code>git checkout develop // переход на ветку develop
git merge master // слияние веток
git log --graph --all // просмотр изменений</code></pre>

				<p>Путём периодического слияния веток можно переносить любые изменения и поддерживать совместимость изменений ветки с изменениями в основной ветке.</p>
				<p>Однако, это делает графики коммитов действительно уродливыми.</p>

				<h3>Перебазирование как альтернатива слиянию</h3>
				<p>Использование команды <code>rebase</code> вместо команды <code>merge</code>:</p>
<pre><code>git checkout develop
git rebase master
git log --graph --all</code></pre>

				<p>Конечный результат перебазирования очень похож на результат слияния. Ветка <code>develop</code> в настоящее время содержит все свои изменения, а также все изменения ветки <code>master</code>. Однако, дерево коммитов значительно отличается.</p>
				<p>Дерево коммитов ветки <code>develop</code> было переписано таким образом, что ветка <code>master</code> является частью истории коммитов. Это делает цепь коммитов линейной и гораздо более читабельной.</p>

				<h3>Когда использовать перебазирование, а когда слияние?</h3>
				<p>Не используйте перебазирование:</p>
				<ul>
					<li>Если ветка является публичной и расшаренной. Переписывание общих веток будет мешать работе других членов команды.</li>
					<li>Когда важна точная история коммитов ветки (так как команда <code>rebase</code> переписывает историю коммитов).</li>
				</ul>

				<p>Учитывая приведённые выше рекомендации, я предпочитаю использовать <code>rebase</code> для кратковременных, локальных веток, а слияние для веток в публичном репозитории.</p>
			</div>
		</section>

		<section>
			<span id="item10"></span>
			<a href="#item10" id="open-item10">Клонирование репозиториев</a>
			<a href="#items" id="close-item10">Клонирование репозиториев</a>
			<div class="content">
				<p>Перед клонированием нужно находиться в рабочем каталоге, где нужно создать клон.</p>
				<p>Для проверки, можно узнать текущее месторасположение:</p>
<pre><code>pwd // показывает полный путь к текущему каталогу
ls // показывает содержимое каталога</code></pre>

				<p>Источником клона может служить как удалённый репозиторий, так и локальный каталог. Если не использовать параметр имени клона, будет создано имя источника.</p>
				<p>Создание клона:</p>
				<pre><code>git clone [источник] [имя копии]</code></pre>
				<p>Например, сделать клон репозитория <a href="https://github.com/AleksiMagner/git-tutor" target="_blank"><code>https://github.com/AleksiMagner/git-tutor</code></a>:</p>
				<pre><code>git clone git@github.com:AleksiMagner/git-tutor.git</code></pre>
				<p>Сделать клон локальной папки <code>work</code>:</p>
				<pre><code>git clone work work_clone</code></pre>
				<p>После создания клона необходимо войти в каталог:</p>
<pre><code>cd git-tutor
или
cd work</code></pre>

				<p>Находясь в клоне:</p>
<pre><code>git remote // удалённое имя оригинального репозитория. По умолчанию origin
git remote show origin // более подробная информация об удалённом репозитории
git branch // список локальных веток клона
git branch -a // список и удалённых, и локальных веток</code></pre>

				<p>Git выводит все коммиты в оригинальный репозиторий, но ветки в удалённом репозитории не рассматриваются как локальные. Если мы хотим собственную ветку, мы должны сами её создать.</p>
			</div>
		</section>

		<section>
			<span id="item11"></span>
			<a href="#item11" id="open-item11">Чистый репозиторий</a>
			<a href="#items" id="close-item11">Чистый репозиторий</a>
			<div class="content">
				<p>Чистые репозитории (без рабочих каталогов) обычно используются для расшаривания.</p>
				<p>Обычный git-репозиторий подразумевает, что вы будете использовать его как рабочую директорию, поэтому вместе с файлами проекта в актуальной версии, git хранит все служебные, «чисто-репозиториевские» файлы в поддиректории <code>.git</code>.</p>
				<p>В удалённых репозиториях нет смысла хранить рабочие файлы на диске (как это делается в рабочих копиях), а всё что им действительно нужно — это дельты изменений и другие бинарные данные репозитория.</p>
				<p>Вот это и есть «чистый репозиторий».</p>
				<p>Перейти в каталог, где находится репозиторий, с которого необходимо сделать чистый репозиторий и выполнить:</p>
				<pre><code>git clone --bare [имя репо] [имя репо].git // создаст чистый репозиторий на основе [имя репо]</code></pre>

				<p>Как правило, репозитории, оканчивающиеся на <code>.git</code> являются чистыми репозиториями.</p>
				<p>В репозитории <code>[имя репо].git</code> нет рабочего каталога. По сути, это есть не что иное, как каталог <code>.git</code> нечистого репозитория.</p>

				<h3>Добавление чистого репозитория к оригинальному в качестве удалённого репозитория</h3>
				<p>Перейти в каталог оригинального репозитория и выполнить:</p>
				<pre><code>git remote add shared ../repo.git</code></pre>
				<p>где <code>../repo.git</code> &ndash; путь к чистому репозиторию.</p>

				<h3>Отправка изменений на общий репозиторий</h3>
				<p>Общим называется репозиторий, получающий отправленные нами изменения.</p>
				<pre><code>git push shared master // shared это имя удалённого репо, master это ветка на которую отправить</code></pre>

				<h3>Извлечение изменений из общего репозитория</h3>
				<p>Если общий репозиторий ещё не добавлен:</p>
				<pre><code>git remote add shared ../repo.git</code></pre>
				<p>где <code>shared</code> &ndash; имя удалённого репо, <code>../repo.git</code> &ndash; путь к нему</p>
				<pre><code>git branch --track shared master // добавил ветку shared, которая отслеживает master на общем репо</code></pre>
				<pre><code>git pull shared master // получение и слитие данных из репо shared, ветка master</code></pre>
			</div>
		</section>

		<section>
			<span id="item12"></span>
			<a href="#item12" id="open-item12">Настройка git сервера для совместного использования репозиториев</a>
			<a href="#items" id="close-item12">Настройка git сервера для совместного использования репозиториев</a>
			<div class="content">
				<p>Перейти в рабочую директорию.</p>
				<p>Запуск git сервера:</p>
				<pre><code>git daemon --verbose --export-all --base-path=.</code></pre>

				<p>Открыть отдельное окно терминала и перейти в рабочую дерикторию.</p>
<pre><code>git clone git://localhost/repo.git network_repo
cd network_repo
ls</code></pre>

				<p>Должна появиться копия проекта repo, которая хранится в чистом репозитори repo.git</p>

				<h3>Отправка в Git Daemon</h3>
				<p>Если вы хотите совершить отправку в репозиторий <code>Git Daemon</code>, добавьте метку <code>--enable=receive-pack</code> к команде <code>git daemon</code>. Будьте осторожны, этот сервер не производит аутентификацию, поэтому любой может отправлять изменения в ваш репозиторий.</p>
			</div>
		</section>

		<section>
			<span id="item13"></span>
			<a href="#item13" id="open-item13">Ресурсы в помощь</a>
			<a href="#items" id="close-item13">Ресурсы в помощь</a>
			<div class="content">
				<p><a href="https://githowto.com/ru" target="_blank">Git How To</a> &ndash; это интерактивный тур, который познакомит вас с основами Git</p>
				<p><a href="https://git-scm.com/book/ru/v2" target="_blank">Книга Pro Git на русском</a></p>
				<p><a href="https://learngitbranching.js.org/" target="_blank">LearnGitBranching</a> &ndash; интерактивное онлайн-приложение, помогает новичкам постичь мощные возможности ветвления и работы с git.</p>
				<p><a href="https://habr.com/ru/post/106912/" target="_blank">Удачная модель ветвления для Git</a> &ndash; используется при разработке проектов.</p>
				<p><a href="http://gitignore.io/" target="_blank">gitignore</a> &ndash; облегчает создание файлов <code>.gitignore</code> для проектов.</p>
			</div>
		</section>
	</main>

</body>
</html>